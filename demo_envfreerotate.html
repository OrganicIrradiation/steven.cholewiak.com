<!DOCTYPE html>
<html lang="en">
    <head>
      <title>Specular Rotation</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
      <style>
	body {
	  font-family: Monospace;
	  background-color: #000;
	  color: #fff;
	  margin: 0px;
	  overflow: hidden;
	}
	#info {
	  color: #fff;
	  position: absolute;
	  top: 10px;
	  width: 100%;
	  text-align: center;
	  z-index: 100;
	  display:block;
	}
	#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
      </style>
    </head>

    <body>        
      <!-- Shaders -->
      <script type="x-shader/x-vertex" id="vertexShader">
	// switch on high precision floats
	#ifdef GL_ES
	precision highp float;
	#endif
        #define M_PI 3.1415926535897932384626433832795
	
	uniform mat4 VIEWMATRIX;
	uniform mat4 VIEWMATRIXINVERSE;
	uniform int LIGHTPROBE;
	
	varying vec3 tNormal;
	varying vec3 viewDirection;
	varying vec3 texCoord;
        varying vec3 diffuseColor;
        
        const float C1 = 0.429043;
        const float C2 = 0.511664;
        const float C3 = 0.743125;
        const float C4 = 0.886227;
        const float C5 = 0.247708;
        
        vec3 shConstants[9];
        
	void main()
	{
            if (LIGHTPROBE == 0) {
                /* Old Town Square */
                shConstants[0] = vec3(0.871297, 0.875222, 0.864470);
                shConstants[1] = vec3(0.175058, 0.245335, 0.312891);
                shConstants[2] = vec3(0.034675, 0.036107, 0.037362);
                shConstants[3] = vec3(-0.004629, -0.029448, -0.048028);
                shConstants[4] = vec3(-0.120535, -0.121160, -0.117507);
                shConstants[5] = vec3(0.003242, 0.003624, 0.007511);
                shConstants[6] = vec3(-0.028667, -0.024926, -0.020998);
                shConstants[7] = vec3(-0.077539, -0.086325, -0.091591);
                shConstants[8] = vec3(-0.161784, -0.191783, -0.219152);
            } else if (LIGHTPROBE == 1) {
                /* Grace Cathedral */
                shConstants[0] = vec3( 0.79, 0.44, 0.54);
                shConstants[1] = vec3( 0.39, 0.35, 0.60);
                shConstants[2] = vec3(-0.34,-0.18,-0.27);
                shConstants[3] = vec3(-0.29,-0.06, 0.01);
                shConstants[4] = vec3(-0.11,-0.05,-0.12);
                shConstants[5] = vec3(-0.26,-0.22,-0.47);
                shConstants[6] = vec3(-0.16,-0.09,-0.15);
                shConstants[7] = vec3( 0.56, 0.21, 0.14);
                shConstants[8] = vec3( 0.21,-0.05,-0.30);
            } else if (LIGHTPROBE == 2) {
                /* Eucalyptus Grove */
                shConstants[0] = vec3( 0.38, 0.43, 0.45);
                shConstants[1] = vec3( 0.29, 0.36, 0.41);
                shConstants[2] = vec3( 0.04, 0.03, 0.01);
                shConstants[3] = vec3(-0.10,-0.10,-0.09);
                shConstants[4] = vec3(-0.06,-0.06,-0.04);
                shConstants[5] = vec3( 0.01,-0.01,-0.05);
                shConstants[6] = vec3(-0.09,-0.13,-0.15);
                shConstants[7] = vec3(-0.06,-0.05,-0.04);
                shConstants[8] = vec3( 0.02, 0.00,-0.05);
            } else if (LIGHTPROBE == 3) {                
                /* St. Peter's Basilica */
                shConstants[0] = vec3( 0.36, 0.26, 0.23);
                shConstants[1] = vec3( 0.18, 0.14, 0.13);
                shConstants[2] = vec3(-0.02,-0.01, 0.00);
                shConstants[3] = vec3( 0.03, 0.02, 0.00);
                shConstants[4] = vec3( 0.02, 0.01, 0.00);
                shConstants[5] = vec3(-0.05,-0.03,-0.01);
                shConstants[6] = vec3(-0.09,-0.08,-0.07);
                shConstants[7] = vec3( 0.01, 0.00, 0.00);
                shConstants[8] = vec3(-0.08,-0.03, 0.00);
            } else if (LIGHTPROBE == 4) {
                /* Uffizi Gallery */
                shConstants[0] = vec3( 0.32, 0.31, 0.35);
                shConstants[1] = vec3( 0.37, 0.37, 0.43);
                shConstants[2] = vec3( 0.00, 0.00, 0.00);
                shConstants[3] = vec3(-0.01,-0.01,-0.01);
                shConstants[4] = vec3(-0.02,-0.02,-0.03);
                shConstants[5] = vec3(-0.01,-0.01,-0.01);
                shConstants[6] = vec3(-0.28,-0.28,-0.32);
                shConstants[7] = vec3( 0.00, 0.00, 0.00);
                shConstants[8] = vec3(-0.24,-0.24,-0.28);
            } else if (LIGHTPROBE == 5) {
                /* Galileo's Tomb */
                shConstants[0] = vec3( 1.04, 0.76, 0.71);
                shConstants[1] = vec3( 0.44, 0.34, 0.34);
                shConstants[2] = vec3(-0.22,-0.18,-0.17);
                shConstants[3] = vec3( 0.71, 0.54, 0.56);
                shConstants[4] = vec3( 0.64, 0.50, 0.52);
                shConstants[5] = vec3(-0.12,-0.09,-0.08);
                shConstants[6] = vec3(-0.37,-0.28,-0.29);
                shConstants[7] = vec3(-0.17,-0.13,-0.13);
                shConstants[8] = vec3( 0.55, 0.42, 0.42);
            } else if (LIGHTPROBE == 6) {
                /* Vine Street Kitchen */
                shConstants[0] = vec3( 0.64, 0.67, 0.73);
                shConstants[1] = vec3( 0.28, 0.32, 0.33);
                shConstants[2] = vec3( 0.42, 0.60, 0.77);
                shConstants[3] = vec3(-0.05,-0.04,-0.02);
                shConstants[4] = vec3(-0.10,-0.08,-0.05);
                shConstants[5] = vec3( 0.25, 0.39, 0.53);
                shConstants[6] = vec3( 0.38, 0.54, 0.71);
                shConstants[7] = vec3( 0.06, 0.01,-0.02);
                shConstants[8] = vec3(-0.03,-0.02,-0.03);
            } else if (LIGHTPROBE == 7) {
                /* Breezeway */
                shConstants[0] = vec3( 0.32, 0.36, 0.38);
                shConstants[1] = vec3( 0.37, 0.41, 0.45);
                shConstants[2] = vec3(-0.01,-0.01,-0.01);
                shConstants[3] = vec3(-0.10,-0.12,-0.12);
                shConstants[4] = vec3(-0.13,-0.15,-0.17);
                shConstants[5] = vec3(-0.01,-0.02, 0.02);
                shConstants[6] = vec3(-0.07,-0.08,-0.09);
                shConstants[7] = vec3( 0.02, 0.03, 0.03);
                shConstants[8] = vec3(-0.29,-0.32,-0.36);
            } else if (LIGHTPROBE == 8) {
                /* Campus Sunset */
                shConstants[0] = vec3( 0.79, 0.94, 0.98);
                shConstants[1] = vec3( 0.44, 0.56, 0.70);
                shConstants[2] = vec3(-0.10,-0.18,-0.27);
                shConstants[3] = vec3( 0.45, 0.38, 0.20);
                shConstants[4] = vec3( 0.18, 0.14, 0.05);
                shConstants[5] = vec3(-0.14,-0.22,-0.31);
                shConstants[6] = vec3(-0.39,-0.40,-0.36);
                shConstants[7] = vec3( 0.09, 0.07, 0.04);
                shConstants[8] = vec3( 0.67, 0.67, 0.52);
            } else if (LIGHTPROBE == 9) {
                /* Funston Beach Sunset */
                shConstants[0] = vec3( 0.68, 0.69, 0.70);
                shConstants[1] = vec3( 0.32, 0.37, 0.44);
                shConstants[2] = vec3(-0.17,-0.17,-0.17);
                shConstants[3] = vec3(-0.45,-0.42,-0.34);
                shConstants[4] = vec3(-0.17,-0.17,-0.15);
                shConstants[5] = vec3(-0.08,-0.09,-0.10);
                shConstants[6] = vec3(-0.03,-0.02,-0.01);
                shConstants[7] = vec3( 0.16, 0.14, 0.10);
                shConstants[8] = vec3( 0.37, 0.31, 0.20);
            }
            
            /* The calculated spherical harmonic should be based upon the normal
               vector, not the reflected direction.  For more information, check
               here:
                https://en.wikibooks.org/wiki/GLSL_Programming/Blender/Reflecting_Surfaces
            */
            vec4 positionInViewSpace = vec4(position,1.0);
            vec4 viewDirectionInViewSpace = positionInViewSpace - vec4(0.0, 0.0, 100.0, 1.0);
            viewDirection = vec3(VIEWMATRIXINVERSE * viewDirectionInViewSpace);
            
            vec3 normalDirectionInViewSpace = normalMatrix * normal;
            tNormal = vec3(vec4(normalDirectionInViewSpace, 0.0) * VIEWMATRIX);
            
            diffuseColor = C1 * shConstants[8] * (tNormal.x * tNormal.x - tNormal.y * tNormal.y) +
                           C3 * shConstants[6] * tNormal.z * tNormal.z +
                           C4 * shConstants[0] -
                           C5 * shConstants[6] +
                           2.0 * C1 * shConstants[4] * tNormal.x * tNormal.y +
                           2.0 * C1 * shConstants[7] * tNormal.x * tNormal.z +
                           2.0 * C1 * shConstants[5] * tNormal.y * tNormal.z +
                           2.0 * C2 * shConstants[3] * tNormal.x +
                           2.0 * C2 * shConstants[1] * tNormal.y +
                           2.0 * C2 * shConstants[2] * tNormal.z;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
            texCoord = (position.xyz/2.0+0.5)*2.0;
	}
      </script>
      
      <script type="x-shader/x-fragment" id="fragmentShader">
	#ifdef GL_ES
	precision highp float;
	#endif
	
	uniform sampler2D INPUTIMAGE;
	uniform sampler2D TEXTURE3D;
	uniform float SPECULARGAIN;
	uniform float TEXTUREGAIN;
	uniform float SHADINGGAIN;
	
	varying vec3 tNormal;
	varying vec3 viewDirection;
	varying vec3 texCoord;
        varying vec3 diffuseColor;
	
	vec2 computeSliceOffset(float slice, float slicesPerRow, vec2 sliceSize) {
	  return sliceSize * vec2(mod(slice, slicesPerRow), 
				  floor(slice / slicesPerRow));
	}
	
	vec4 sampleAs3DTexture(
	    sampler2D tex, vec3 texCoord, float size, float numRows, float slicesPerRow) {
	  float slice   = mod(texCoord.z,1.0) * size;
	  float sliceZ  = floor(slice);                         // slice we need
	  float zOffset = fract(slice);                         // dist between slices
	
	  vec2 sliceSize = vec2(1.0 / slicesPerRow,             // u space of 1 slice
				1.0 / numRows);                 // v space of 1 slice
	
	  vec2 slicePixelSize = sliceSize / size;               // space of 1 pixel
	  vec2 sliceInnerSize = slicePixelSize * (size - 1.0);  // space of size pixels
	
	  vec2 slice0Offset = computeSliceOffset(sliceZ, slicesPerRow, sliceSize);
	  vec2 slice1Offset = computeSliceOffset(sliceZ + 1.0, slicesPerRow, sliceSize);
	
	  vec2 uv = slicePixelSize * 0.5 + mod(texCoord.xy,1.0) * sliceInnerSize;
	  vec4 slice0Color = texture2D(tex, slice0Offset + uv);
	  vec4 slice1Color = texture2D(tex, slice1Offset + uv);
	  //return mix(slice0Color, slice1Color, zOffset);
	  return slice0Color;
	}
	
	void main()
	{
	  /* See: http://www.pauldebevec.com/RNL/Source/angmap.cal */
	  vec3 DD = reflect(normalize(viewDirection), normalize(tNormal));
	  // 1/(2pi)
	  float r = 0.159154943*acos(DD.z)/sqrt(DD.x*DD.x + DD.y*DD.y);
	  vec2 finalCoordinates = vec2(0,0);
	  finalCoordinates.x = DD.x * r + 0.5;
	  finalCoordinates.y = DD.y * r + 0.5;
	  
	  // Texture
	  gl_FragColor = (sampleAs3DTexture(TEXTURE3D,texCoord,256.0,16.0,16.0)*TEXTUREGAIN + (1.0-TEXTUREGAIN)/2.0);
	  // Shading
	  gl_FragColor = gl_FragColor * vec4(diffuseColor, 1.0) * SHADINGGAIN;
	  // Specular
	  gl_FragColor = gl_FragColor + texture2D(INPUTIMAGE, finalCoordinates) * SPECULARGAIN;
	}
      </script>
      
      <script src="js/threejs/three.min.js"></script>
      <script src="js/threejs/loaders/OBJLoader.js"></script>
      
      <script src="js/threejs/Detector.js"></script>
      <script src="js/threejs/libs/stats.min.js"></script>
      
      <script type='text/javascript' src='js/dat.gui.min.js'></script>
      
      <script>
	var uniformVals, container, stats;
	var aspectRatio = 1, camera, scene, renderer;
	var environmentRotation = 0;
	var lightProbe =  new Array();
	var TEXTURE3D;
	var effectController;
	var manager;
	
	init();
	animate();
	
	function init() {
	  container = document.createElement( "div" );
	  document.body.appendChild( container );
	  
	  //camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
	  aspectRatio = window.innerWidth / window.innerHeight;
	  camera = new THREE.OrthographicCamera( -aspectRatio*2, aspectRatio*2, 2, -2, 0.01, 1000 );
	  camera.position.z = 5;
	  
	  // scene
	  scene = new THREE.Scene();
	  
	  manager = new THREE.LoadingManager();
	  manager.onProgress = function ( item, loaded, total ) {
	    console.log( item, loaded, total );
	  };
	  
	  // Texture
	  lightProbe[1] = THREE.ImageUtils.loadTexture( "images/grace_probe.jpg" );
	  lightProbe[2] = THREE.ImageUtils.loadTexture( "images/rnl_probe.jpg" );
	  lightProbe[3] = THREE.ImageUtils.loadTexture( "images/stpeters_probe.jpg" );
	  lightProbe[4] = THREE.ImageUtils.loadTexture( "images/uffizi_probe.jpg" );
	  lightProbe[5] = THREE.ImageUtils.loadTexture( "images/galileo_probe.jpg" );
	  lightProbe[6] = THREE.ImageUtils.loadTexture( "images/kitchen_probe.jpg" );
	  lightProbe[7] = THREE.ImageUtils.loadTexture( "images/building_probe.jpg" );
	  lightProbe[8] = THREE.ImageUtils.loadTexture( "images/campus_probe.jpg" );
	  lightProbe[9] = THREE.ImageUtils.loadTexture( "images/beach_probe.jpg" );
	  
	  TEXTURE3D = THREE.ImageUtils.loadTexture( "images/TEXTURE3D-2D.png" );
	  TEXTURE3D.magFilter = THREE.LinearFilter;
	  TEXTURE3D.minFilter = THREE.LinearFilter;
	  
	  // Shader
	  uniformVals = {
	    "SPECULARGAIN": { type: "f", value: 1.0 },
	    "INPUTIMAGE": { type: "t", value: lightProbe[1] },
	    "TEXTURE3D": { type: "t", value: TEXTURE3D },
	    "VIEWMATRIX": { type: "m4", value: new THREE.Matrix4()},
	    "VIEWMATRIXINVERSE": { type: "m4", value: new THREE.Matrix4()},
	    "LIGHTPROBE": { type: "i", value: 1 },
	    "TEXTUREGAIN": { type: "f", value: 0 },
	    "SHADINGGAIN": { type: "f", value: 0 }
	  }
	  materialSpecular = new THREE.ShaderMaterial({
	    vertexShader: document.getElementById("vertexShader").textContent,
	    fragmentShader: document.getElementById("fragmentShader").textContent,
	    uniforms: uniformVals
	  });
	  // Normal Material
	  materialNormal = new THREE.MeshNormalMaterial();
	  
	  loadModel("webgl_models/MedFreq_MedAmp.obj");
	  
	  // Light-probe sphere
	  var sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 100, 100));
	  sphere.traverse( function ( child ) {
	    if ( child instanceof THREE.Mesh ) {
	      child.material = materialSpecular;
	    }
	  } );
	  sphere.name = "theSphere";
	  sphere.translateX( 2.25 );
	  scene.add(sphere);
	  
	  stats = new Stats();
	  stats.domElement.style.position = "absolute";
	  stats.domElement.style.top = "0px";
	  stats.domElement.style.zIndex = 100;
	  container.appendChild( stats.domElement );
	  
	  renderer = new THREE.WebGLRenderer({'antialias':true});
	  renderer.setSize( window.innerWidth, window.innerHeight );
	  container.appendChild( renderer.domElement );
	  
	  window.addEventListener( "resize", onWindowResize, false );
	  
	  effectController = {
	    shapeRotSpeed: 2,
	    shapeRotAngle: 2,
	    envRotSpeed: 0,
	    LightProbe: 1,
	    TextureGain: 0.0,
	    ShadingGain: 0.0,
	    SpecularGain: 1.0,
	    ModelFreq: 'Med',
	    ModelAmp: 'Med',
	    HighRes: false
	  }
	  
	  effectControllerPresets = {
	    "preset": "Default",
	    "remembered": {
	      "Default": {
		"0": {
		  "shapeRotSpeed": 2,
		  "shapeRotAngle": 90,
		  "envRotSpeed": 6,
		}
	      },
	      "Increased Speed": {
		"0": {
		  "shapeRotSpeed": 2,
		  "shapeRotAngle": 0,
		  "envRotSpeed": 10
		}
	      },
	      "Deformation": {
		"0": {
		  "shapeRotSpeed": 2,
		  "shapeRotAngle": 0,
		  "envRotSpeed": -10
		}
	      }
	    }
	  };
	  
	  var gui = new dat.GUI({load: effectControllerPresets});
      gui.close();
	  gui.remember(effectController);
	  gui.add(effectController, 'shapeRotSpeed', -5, 5 ).step(1);
	  gui.add(effectController, 'shapeRotAngle', 0, 360 ).step(1);
	  gui.add(effectController, 'envRotSpeed', -10, 10 ).step(1);
	  var controllerLP = gui.add(effectController, 'LightProbe', { 'Grace Cathedral, San Francisco': 1, 'Eucalyptus Grove, UC Berkeley': 2, 'St. Peter\'s Basilica, Rome': 3, 'The Uffizi Gallery, Florence': 4, 'Galileo\'s Tomb, Santa Croce, Florence': 5, 'Kitchen at 2213 Vine St': 6, 'Overcast Breezeway, Soda Hall': 7, 'Campus at Sunset': 8, 'Funston Beach at Sunset': 9 } );
	  
	  var f1 = gui.addFolder('Gains')
          var controllerSpecularGain = f1.add(effectController, 'SpecularGain', 0.0, 1.0);
	  var controllerTextureGain = f1.add(effectController, 'TextureGain', 0.0, 1.0);
          var controllerShadingGain = f1.add(effectController, 'ShadingGain', 0.0, 1.0);
	  
	  var f2 = gui.addFolder('Shape')
	  var controllerModelFreq = f2.add(effectController, 'ModelFreq', ['Low', 'Med', 'High'] );
	  var controllerModelAmp = f2.add(effectController, 'ModelAmp', ['Low', 'Med', 'High'] );
	  var controllerHighRes = f2.add(effectController, 'HighRes' );
            
	  controllerLP.onChange(function(value) {
            var object_b = scene.getObjectByName( "blob_b",true );
            var sphere = scene.getObjectByName( "theSphere",true );
	    changeLightProbe(object_b,value);
	    changeLightProbe(sphere,value);
	  });
	  
	  controllerSpecularGain.onChange(function(value) {
            var object_b = scene.getObjectByName( "blob_b",true );
	    object_b.traverse( function ( child ) {
	      if ( child instanceof THREE.Mesh ) {
		child.material.uniforms.SPECULARGAIN.value = value;
	      }
	    } );
	  });
	  controllerTextureGain.onChange(function(value) {
            var object_b = scene.getObjectByName( "blob_b",true );
	    object_b.traverse( function ( child ) {
	      if ( child instanceof THREE.Mesh ) {
		child.material.uniforms.TEXTUREGAIN.value = value;
	      }
	    } );
	  });
	  controllerShadingGain.onChange(function(value) {
            var object_b = scene.getObjectByName( "blob_b",true );
	    object_b.traverse( function ( child ) {
	      if ( child instanceof THREE.Mesh ) {
		child.material.uniforms.SHADINGGAIN.value = value;
	      }
	    } );
	  });
          
	  controllerModelFreq.onChange(function(value) {
	    deleteOBJs();
	    if (effectController.HighRes == true) {
	      loadModel('webgl_models/'+value+'Freq_'+effectController.ModelAmp+'AmpHR.obj');
	    } else {
	      loadModel('webgl_models/'+value+'Freq_'+effectController.ModelAmp+'Amp.obj');
	    }
	  });
	  controllerModelAmp.onChange(function(value) {
	    deleteOBJs();
	    if (effectController.HighRes == true) {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+value+'AmpHR.obj');
	    } else {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+value+'Amp.obj');
	    }
	  });
	  controllerHighRes.onChange(function(value) {
	    deleteOBJs();
	    if (value == true) {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+effectController.ModelAmp+'AmpHR.obj');
	    } else {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+effectController.ModelAmp+'Amp.obj');
	    }
	  });
	}
	
	function deleteOBJs() {
	  var object_a = scene.getObjectByName( "blob_a",true );
	  var object_b = scene.getObjectByName( "blob_b",true );
	  scene.remove(object_a);
	  scene.remove(object_b);
	}
	
	function loadModel(filename) {
	  // Normal Model
	  var loader = new THREE.OBJLoader( manager );
	  loader.load( filename, function ( object ) {
	    object_b = object.clone();
	    object_b.traverse( function ( child ) {
	      if ( child instanceof THREE.Mesh ) {
		child.material = materialSpecular;
		// Needed to add to avoid face faceting
		child.geometry.computeVertexNormals();
		child.geometry.computeFaceNormals();
	      }
	    } );
	    object_b.name = "blob_b";
	    scene.add( object_b );
	    
	    object_a = object.clone();
	    object_a.traverse( function ( child ) {
	      if ( child instanceof THREE.Mesh ) {
		child.material = materialNormal;
		// Needed to add to avoid face faceting
		child.geometry.computeVertexNormals();
		child.geometry.computeFaceNormals();
	      }
	    } );
	    object_a.name = "blob_a";
	    object_a.translateX( -2.25 );
	    scene.add( object_a );
	  } );
	};
	
	function changeLightProbe(object,LP) {
	  object.traverse( function ( child ) {
	    if ( child instanceof THREE.Mesh ) {
	      child.material.uniforms.INPUTIMAGE.value = lightProbe[LP];
	      child.material.uniforms.LIGHTPROBE.value = LP;
	    }
	  } );
	}
	
	function onWindowResize() {
	  aspectRatio = window.innerWidth / window.innerHeight;
	  camera.left = -aspectRatio*2;
	  camera.right = aspectRatio*2;
	  camera.updateProjectionMatrix();
	  
	  renderer.setSize( window.innerWidth, window.innerHeight );
	}
	
	function animate() {
	  requestAnimationFrame( animate );
	  render();
	  stats.update();
	}
	
	function rotateViewMatrix(object,theta) {
	  var VIEWMATRIX = new THREE.Matrix4();
	  var VIEWMATRIXINVERSE = new THREE.Matrix4();
	  var cameraCopy = camera.clone();
	  
	  cameraCopy.position.x = 5 * Math.sin(theta);
	  cameraCopy.position.z = 5 * Math.cos(theta);
	  cameraCopy.lookAt( scene.position );
	  cameraCopy.updateMatrixWorld( true );
	  VIEWMATRIX = cameraCopy.matrixWorld;
	  VIEWMATRIXINVERSE.getInverse(VIEWMATRIX);
	  
	  object.traverse( function ( child ) {
	    if ( child instanceof THREE.Mesh ) {
	      child.material.uniforms.VIEWMATRIX.value = VIEWMATRIX;
	      child.material.uniforms.VIEWMATRIXINVERSE.value = VIEWMATRIXINVERSE;
	    }
	  } );
	}
	
	// See: http://stackoverflow.com/a/11060965
	// Rotate an object around an arbitrary axis in object space
	var rotObjectMatrix;
	function rotateAroundObjectAxis(object, axis, radians) {
	    rotObjectMatrix = new THREE.Matrix4();
	    rotObjectMatrix.makeRotationAxis(axis.normalize(), radians);
	    object.matrix.multiply(rotObjectMatrix);
	    object.rotation.setFromRotationMatrix(object.matrix);
	}
	var rotWorldMatrix;
	// Rotate an object around an arbitrary axis in world space       
	function rotateAroundWorldAxis(object, axis, radians) {
	    rotWorldMatrix = new THREE.Matrix4();
	    rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);
	    rotWorldMatrix.multiply(object.matrix);                // pre-multiply
	    object.matrix = rotWorldMatrix;
	    object.rotation.setFromRotationMatrix(object.matrix);
	}
	
	function render() {
	  var rotationIncrement = 0.00314159;
	  var yAxis = new THREE.Vector3(0, 1 ,0);
	  var object_a = scene.getObjectByName( "blob_a",true );
	  var object_b = scene.getObjectByName( "blob_b",true );
	  var sphere = scene.getObjectByName( "theSphere",true );
	  
	  //var relativeSpeed = 0;
	  
	  environmentRotation = environmentRotation + effectController.envRotSpeed * rotationIncrement;
	  
	  var rotAxis = new THREE.Vector3(Math.sin((360-effectController.shapeRotAngle)*Math.PI/180),
					Math.cos((360-effectController.shapeRotAngle)*Math.PI/180),0 );
	  
	  if (typeof object_a != "undefined") {
	    rotateAroundWorldAxis(object_a, rotAxis, (effectController.shapeRotSpeed * rotationIncrement));
	  }
	  if (typeof object_b != "undefined") {
	    rotateAroundWorldAxis(object_b, rotAxis, (effectController.shapeRotSpeed * rotationIncrement));
	    rotateViewMatrix(object_b,environmentRotation)
	  }
	  if (typeof sphere != "undefined") {
	    rotateAroundWorldAxis(sphere, rotAxis, (effectController.shapeRotSpeed * rotationIncrement));
	    rotateViewMatrix(sphere,environmentRotation)
	  }
	  
	  camera.lookAt( scene.position );
	  camera.updateMatrixWorld( true );
	  renderer.render( scene, camera );
	}
      </script>
    </body>
</html>