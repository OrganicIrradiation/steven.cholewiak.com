<!DOCTYPE html>
<html lang="en">
    <head>
      <title>Specular Rotation</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
      <style>
	body {
	  font-family: Monospace;
	  background-color: #000;
	  color: #fff;
	  margin: 0px;
	  overflow: hidden;
	}
	#info {
	  color: #fff;
	  position: absolute;
	  top: 10px;
	  width: 100%;
	  text-align: center;
	  z-index: 100;
	  display:block;
	}
	#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
      </style>
    </head>

    <body>        
      <!-- Shaders -->
      <script type="x-shader/x-vertex" id="vertexShader">
	// switch on high precision floats
	#ifdef GL_ES
	precision highp float;
	#endif
        #define M_PI 3.1415926535897932384626433832795
	
	uniform mat4 VIEWMATRIX;
	uniform mat4 VIEWMATRIXINVERSE;
	
	varying vec3 tNormal;
	varying vec3 viewDirection;
        
        vec3 shConstants[9];
        
	void main()
	{
            vec4 positionInViewSpace = vec4(position,1.0);
            vec4 viewDirectionInViewSpace = positionInViewSpace - vec4(0.0, 0.0, 100.0, 1.0);
            viewDirection = vec3(VIEWMATRIXINVERSE * viewDirectionInViewSpace);
            
            vec3 normalDirectionInViewSpace = normalMatrix * normal;
            tNormal = vec3(vec4(normalDirectionInViewSpace, 0.0) * VIEWMATRIX);
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
	}
      </script>
      
      <script type="x-shader/x-fragment" id="fragmentShader">
	#ifdef GL_ES
	precision highp float;
	#endif
	
	uniform sampler2D INPUTIMAGE;
	
	varying vec3 tNormal;
	varying vec3 viewDirection;
	
	
	void main()
	{
	  /* See: http://www.pauldebevec.com/RNL/Source/angmap.cal */
	  vec3 DD = reflect(normalize(viewDirection), normalize(tNormal));
	  // 1/(2pi)
	  float r = 0.159154943*acos(DD.z)/sqrt(DD.x*DD.x + DD.y*DD.y);
	  vec2 finalCoordinates = vec2(0,0);
	  finalCoordinates.x = DD.x * r + 0.5;
	  finalCoordinates.y = DD.y * r + 0.5;
	  
	  // Specular
	  gl_FragColor = texture2D(INPUTIMAGE, finalCoordinates);
	}
      </script>
      
      <script src="js/threejs/three.min.js"></script>
      <script src="js/threejs/loaders/OBJLoader.js"></script>
      
      <script src="js/threejs/Detector.js"></script>
      <script src="js/threejs/libs/stats.min.js"></script>
      
      <script type='text/javascript' src='js/dat.gui.min.js'></script>
      
      <script>
	var container, stats;
	var aspectRatio = 1, camera, scene, renderer;
	var environmentRotation = 0;
	var lightProbe =  new Array();
	var TEXTURE3D;
	var effectController;
	var manager;
	
	init();
	animate();
	
	function init() {
	  container = document.createElement( "div" );
	  document.body.appendChild( container );
	  
	  //camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
	  aspectRatio = window.innerWidth / window.innerHeight;
	  camera = new THREE.OrthographicCamera( -aspectRatio*2, aspectRatio*2, 2, -2, 0.01, 1000 );
	  camera.position.z = 5;
	  
	  // scene
	  scene = new THREE.Scene();
	  
	  manager = new THREE.LoadingManager();
	  manager.onProgress = function ( item, loaded, total ) {
	    console.log( item, loaded, total );
	  };
	  
	  // Texture
	  lightProbe[1] = THREE.ImageUtils.loadTexture( "images/sphere_map_1.png" );
	  lightProbe[2] = THREE.ImageUtils.loadTexture( "images/sphere_map_2.png" );
	  lightProbe[3] = THREE.ImageUtils.loadTexture( "images/sphere_map_3.png" );
	  lightProbe[4] = THREE.ImageUtils.loadTexture( "images/sphere_map_4.png" );
	  lightProbe[5] = THREE.ImageUtils.loadTexture( "images/sphere_map_5.png" );
	  lightProbe[6] = THREE.ImageUtils.loadTexture( "images/sphere_map_6.png" );
	  lightProbe[7] = THREE.ImageUtils.loadTexture( "images/sphere_map_7.png" );
	  lightProbe[8] = THREE.ImageUtils.loadTexture( "images/sphere_map_8.png" );
	  lightProbe[9] = THREE.ImageUtils.loadTexture( "images/sphere_map_9.png" );
	  lightProbe_pink = THREE.ImageUtils.loadTexture( "images/sphere_map_pink.png" );
	  lightProbe_brown = THREE.ImageUtils.loadTexture( "images/sphere_map_brown.png" );
	  lightProbe_white = THREE.ImageUtils.loadTexture( "images/sphere_map_white.png" );
	  
	  // Shader
	  materialA = new THREE.ShaderMaterial({
	    vertexShader: document.getElementById("vertexShader").textContent,
	    fragmentShader: document.getElementById("fragmentShader").textContent,
	    uniforms: {
               "INPUTIMAGE": { type: "t", value: lightProbe[1] },
               "VIEWMATRIX": { type: "m4", value: new THREE.Matrix4()},
               "VIEWMATRIXINVERSE": { type: "m4", value: new THREE.Matrix4()}
             }
	  });
	  materialB = new THREE.ShaderMaterial({
	    vertexShader: document.getElementById("vertexShader").textContent,
	    fragmentShader: document.getElementById("fragmentShader").textContent,
	    uniforms: {
               "INPUTIMAGE": { type: "t", value: lightProbe[3] },
               "VIEWMATRIX": { type: "m4", value: new THREE.Matrix4()},
               "VIEWMATRIXINVERSE": { type: "m4", value: new THREE.Matrix4()}
             }
	  });
	  materialC = new THREE.ShaderMaterial({
	    vertexShader: document.getElementById("vertexShader").textContent,
	    fragmentShader: document.getElementById("fragmentShader").textContent,
	    uniforms: {
               "INPUTIMAGE": { type: "t", value: lightProbe[5] },
               "VIEWMATRIX": { type: "m4", value: new THREE.Matrix4()},
               "VIEWMATRIXINVERSE": { type: "m4", value: new THREE.Matrix4()}
             }
	  });
	  materialD = new THREE.ShaderMaterial({
	    vertexShader: document.getElementById("vertexShader").textContent,
	    fragmentShader: document.getElementById("fragmentShader").textContent,
	    uniforms: {
               "INPUTIMAGE": { type: "t", value: lightProbe_pink },
               "VIEWMATRIX": { type: "m4", value: new THREE.Matrix4()},
               "VIEWMATRIXINVERSE": { type: "m4", value: new THREE.Matrix4()}
             }
	  });
	  materialE = new THREE.ShaderMaterial({
	    vertexShader: document.getElementById("vertexShader").textContent,
	    fragmentShader: document.getElementById("fragmentShader").textContent,
	    uniforms: {
               "INPUTIMAGE": { type: "t", value: lightProbe_brown },
               "VIEWMATRIX": { type: "m4", value: new THREE.Matrix4()},
               "VIEWMATRIXINVERSE": { type: "m4", value: new THREE.Matrix4()}
             }
	  });
	  materialF = new THREE.ShaderMaterial({
	    vertexShader: document.getElementById("vertexShader").textContent,
	    fragmentShader: document.getElementById("fragmentShader").textContent,
	    uniforms: {
               "INPUTIMAGE": { type: "t", value: lightProbe_white },
               "VIEWMATRIX": { type: "m4", value: new THREE.Matrix4()},
               "VIEWMATRIXINVERSE": { type: "m4", value: new THREE.Matrix4()}
             }
	  });
	  
	  loadModel("webgl_models/MedFreq_MedAmp.obj");
	  
	  stats = new Stats();
	  stats.domElement.style.position = "absolute";
	  stats.domElement.style.top = "0px";
	  stats.domElement.style.zIndex = 100;
	  container.appendChild( stats.domElement );
	  
	  renderer = new THREE.WebGLRenderer({'antialias':true});
	  renderer.setSize( window.innerWidth, window.innerHeight );
	  container.appendChild( renderer.domElement );
	  
	  window.addEventListener( "resize", onWindowResize, false );
	  
	  effectController = {
	    shapeRotSpeed: 1,
	    envRotSpeed: 0,
	    ModelFreq: 'Med',
	    ModelAmp: 'Med',
	    HighRes: false
	  }
	  
	  effectControllerPresets = {
	    "preset": "Default",
	    "remembered": {
	      "Default": {
		"0": {
		  "shapeRotSpeed": 1,
		  "envRotSpeed": 0,
		}
	      }
	    }
	  };
	  
	  var gui = new dat.GUI({load: effectControllerPresets});
          gui.close();
	  gui.remember(effectController);
	  gui.add(effectController, 'shapeRotSpeed', -5, 5 ).step(1);
	  gui.add(effectController, 'envRotSpeed', -10, 10 ).step(1);
	  
	  var f2 = gui.addFolder('Shape')
	  var controllerModelFreq = f2.add(effectController, 'ModelFreq', ['Low', 'Med', 'High'] );
	  var controllerModelAmp = f2.add(effectController, 'ModelAmp', ['Low', 'Med', 'High'] );
	  var controllerHighRes = f2.add(effectController, 'HighRes' );
          
	  controllerModelFreq.onChange(function(value) {
	    deleteOBJs();
	    if (effectController.HighRes == true) {
	      loadModel('webgl_models/'+value+'Freq_'+effectController.ModelAmp+'AmpHR.obj')
	    } else {
	      loadModel('webgl_models/'+value+'Freq_'+effectController.ModelAmp+'Amp.obj');
	    }
	  });
	  controllerModelAmp.onChange(function(value) {
	    deleteOBJs();
	    if (effectController.HighRes == true) {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+value+'AmpHR.obj');
	    } else {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+value+'Amp.obj');
	    }
	  });
	  controllerHighRes.onChange(function(value) {
	    deleteOBJs();
	    if (value == true) {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+effectController.ModelAmp+'AmpHR.obj');
	    } else {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+effectController.ModelAmp+'Amp.obj');
	    }
	  });
	}
	
	function deleteOBJs() {
	  var objectA = scene.getObjectByName( "blobA", true );
	  var objectB = scene.getObjectByName( "blobB", true );
	  var objectC = scene.getObjectByName( "blobC", true );
	  var objectD = scene.getObjectByName( "blobD", true );
	  var objectE = scene.getObjectByName( "blobE", true );
	  var objectF = scene.getObjectByName( "blobF", true );
	  scene.remove(objectA);
	  scene.remove(objectB);
	  scene.remove(objectC);
	  scene.remove(objectD);
	  scene.remove(objectE);
	  scene.remove(objectF);
	}
        
	function loadModel(filename) {
	  var loader = new THREE.OBJLoader( manager );
	  loader.load( filename, function ( object ) {
	    object.children[0].geometry.applyMatrix(new THREE.Matrix4().makeScale( 0.85, 0.85, 0.85 ) );
	    
	    object_a = object.clone();
	    object_a.children[0].material = materialA;
	    object_a.children[0].geometry.computeVertexNormals();
	    object_a.children[0].geometry.computeFaceNormals();
	    object_a.name = "blobA";
	    object_a.translateX( -2 );
	    object_a.translateY( 1 );
	    scene.add( object_a );
	    
	    object_b = object.clone();
	    object_b.children[0].material = materialB;
	    object_b.children[0].geometry.computeVertexNormals();
	    object_b.children[0].geometry.computeFaceNormals();
	    object_b.name = "blobB";
	    object_b.translateX( 0 );
	    object_b.translateY( 1 );
	    scene.add( object_b );
	    
	    object_c = object.clone();
	    object_c.children[0].material = materialC;
	    object_c.children[0].geometry.computeVertexNormals();
	    object_c.children[0].geometry.computeFaceNormals();
	    object_c.name = "blobC";
	    object_c.translateX( 2 );
	    object_c.translateY( 1 );
	    scene.add( object_c );
	    
	    object_d = object.clone();
	    object_d.children[0].material = materialD;
	    object_d.children[0].geometry.computeVertexNormals();
	    object_d.children[0].geometry.computeFaceNormals();
	    object_d.name = "blobD";
	    object_d.translateX( -2 );
	    object_d.translateY( -1 );
	    scene.add( object_d );
	    
	    object_e = object.clone();
	    object_e.children[0].material = materialE;
	    object_e.children[0].geometry.computeVertexNormals();
	    object_e.children[0].geometry.computeFaceNormals();
	    object_e.name = "blobE";
	    object_e.translateX( 0 );
	    object_e.translateY( -1 );
	    scene.add( object_e );
	    
	    object_f = object.clone();
	    object_f.children[0].material = materialF;
	    object_f.children[0].geometry.computeVertexNormals();
	    object_f.children[0].geometry.computeFaceNormals();
	    object_f.name = "blobF";
	    object_f.translateX( 2 );
	    object_f.translateY( -1 );
	    scene.add( object_f );
	  } );
	};
        
	function onWindowResize() {
	  aspectRatio = window.innerWidth / window.innerHeight;
	  camera.left = -aspectRatio*2;
	  camera.right = aspectRatio*2;
	  camera.updateProjectionMatrix();
	  
	  renderer.setSize( window.innerWidth, window.innerHeight );
	}
	
	function animate() {
	  requestAnimationFrame( animate );
	  render();
	  stats.update();
	}
	
	function rotateViewMatrix(object,theta) {
	  var VIEWMATRIX = new THREE.Matrix4();
	  var VIEWMATRIXINVERSE = new THREE.Matrix4();
	  var cameraCopy = camera.clone();
	  
	  cameraCopy.position.x = 5 * Math.sin(theta);
	  cameraCopy.position.z = 5 * Math.cos(theta);
	  cameraCopy.lookAt( scene.position );
	  cameraCopy.updateMatrixWorld( true );
	  VIEWMATRIX = cameraCopy.matrixWorld;
	  VIEWMATRIXINVERSE.getInverse(VIEWMATRIX);
	  
	  object.traverse( function ( child ) {
	    if ( child instanceof THREE.Mesh ) {
	      child.material.uniforms.VIEWMATRIX.value = VIEWMATRIX;
	      child.material.uniforms.VIEWMATRIXINVERSE.value = VIEWMATRIXINVERSE;
	    }
	  } );
	}
	
	function render() {
	  var rotationIncrement = 0.00314159;
	  var yAxis = new THREE.Vector3(0,1,0);
	  var objectA = scene.getObjectByName( "blobA", true );
	  var objectB = scene.getObjectByName( "blobB", true );
	  var objectC = scene.getObjectByName( "blobC", true );
	  var objectD = scene.getObjectByName( "blobD", true );
	  var objectE = scene.getObjectByName( "blobE", true );
	  var objectF = scene.getObjectByName( "blobF", true );
	  
	  //var relativeSpeed = 0;
	  
	  environmentRotation = environmentRotation + effectController.envRotSpeed * rotationIncrement;
	  
	  if (typeof objectA != "undefined") {
	    objectA.rotateOnAxis(yAxis,(effectController.shapeRotSpeed * rotationIncrement));
	    rotateViewMatrix(objectA,environmentRotation)
	  }
	  if (typeof objectB != "undefined") {
	    objectB.rotateOnAxis(yAxis,(effectController.shapeRotSpeed * rotationIncrement));
	    rotateViewMatrix(objectB,environmentRotation)
	  }
	  if (typeof objectC != "undefined") {
	    objectC.rotateOnAxis(yAxis,(effectController.shapeRotSpeed * rotationIncrement));
	    rotateViewMatrix(objectC,environmentRotation)
	  }
	  if (typeof objectD != "undefined") {
	    objectD.rotateOnAxis(yAxis,(effectController.shapeRotSpeed * rotationIncrement));
	    rotateViewMatrix(objectD,environmentRotation)
	  }
	  if (typeof objectE != "undefined") {
	    objectE.rotateOnAxis(yAxis,(effectController.shapeRotSpeed * rotationIncrement));
	    rotateViewMatrix(objectE,environmentRotation)
	  }
	  if (typeof objectF != "undefined") {
	    objectF.rotateOnAxis(yAxis,(effectController.shapeRotSpeed * rotationIncrement));
	    rotateViewMatrix(objectF,environmentRotation)
	  }
	  
	  camera.lookAt( scene.position );
	  camera.updateMatrixWorld( true );
	  renderer.render( scene, camera );
	}
      </script>
    </body>
</html>