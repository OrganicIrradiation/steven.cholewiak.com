<!DOCTYPE html>
<html lang="en">
    <head>
      <title>Specular Rotation</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
      <style>
	body {
	  font-family: Monospace;
	  background-color: #000;
	  color: #fff;
	  margin: 0px;
	  overflow: hidden;
	}
	#info {
	  color: #fff;
	  position: absolute;
	  top: 10px;
	  width: 100%;
	  text-align: center;
	  z-index: 100;
	  display:block;
	}
	#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
      </style>
    </head>

    <body>        
      <!-- Shaders -->
      <script type="x-shader/x-vertex" id="vertexShader">
	// switch on high precision floats
	#ifdef GL_ES
	precision highp float;
	#endif
        #define M_PI 3.1415926535897932384626433832795
	
	uniform mat4 VIEWMATRIX;
	uniform mat4 VIEWMATRIXINVERSE;
	
	varying vec3 tNormal;
	varying vec3 viewDirection;
        
        vec3 shConstants[9];
        
	void main()
	{
            vec4 positionInViewSpace = vec4(position,1.0);
            vec4 viewDirectionInViewSpace = positionInViewSpace - vec4(0.0, 0.0, 100.0, 1.0);
            viewDirection = vec3(VIEWMATRIXINVERSE * viewDirectionInViewSpace);
            
            vec3 normalDirectionInViewSpace = normalMatrix * normal;
            tNormal = vec3(vec4(normalDirectionInViewSpace, 0.0) * VIEWMATRIX);
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
	}
      </script>
      
      <script type="x-shader/x-fragment" id="fragmentShader">
	#ifdef GL_ES
	precision highp float;
	#endif
	
	uniform sampler2D INPUTIMAGE;
	
	varying vec3 tNormal;
	varying vec3 viewDirection;
	
	
	void main()
	{
	  /* See: http://www.pauldebevec.com/RNL/Source/angmap.cal */
	  vec3 DD = reflect(normalize(viewDirection), normalize(tNormal));
	  // 1/(2pi)
	  float r = 0.159154943*acos(DD.z)/sqrt(DD.x*DD.x + DD.y*DD.y);
	  vec2 finalCoordinates = vec2(0,0);
	  finalCoordinates.x = DD.x * r + 0.5;
	  finalCoordinates.y = DD.y * r + 0.5;
	  
	  // Specular
	  gl_FragColor = texture2D(INPUTIMAGE, finalCoordinates);
	}
      </script>
      
      <script src="js/threejs/three.min.js"></script>
      <script src="js/threejs/loaders/OBJLoader.js"></script>
      
      <script src="js/threejs/Detector.js"></script>
      <script src="js/threejs/libs/stats.min.js"></script>
      
      <script type='text/javascript' src='js/dat.gui.min.js'></script>
      
      <script>
	var container, stats;
	var aspectRatio = 1, camera, scene, renderer;
	var environmentRotation = 0;
	var lightProbe =  new Array();
	var material =  new Array();
	var TEXTURE3D;
	var effectController;
	var manager;
	
	init();
	animate();
	
	function init() {
	  container = document.createElement( "div" );
	  document.body.appendChild( container );
	  
	  //camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
	  aspectRatio = window.innerWidth / window.innerHeight;
	  camera = new THREE.OrthographicCamera( -aspectRatio*2, aspectRatio*2, 2, -2, 0.01, 1000 );
	  camera.position.z = 5;
	  
	  // scene
	  scene = new THREE.Scene();
	  
	  manager = new THREE.LoadingManager();
	  manager.onProgress = function ( item, loaded, total ) {
	    console.log( item, loaded, total );
	  };
	  
	  // Texture
	  lightProbe[1] = THREE.ImageUtils.loadTexture( "images/sphere_map_1.png" );
	  lightProbe[2] = THREE.ImageUtils.loadTexture( "images/sphere_map_2.png" );
	  lightProbe[3] = THREE.ImageUtils.loadTexture( "images/sphere_map_3.png" );
	  lightProbe[4] = THREE.ImageUtils.loadTexture( "images/sphere_map_4.png" );
	  lightProbe[5] = THREE.ImageUtils.loadTexture( "images/sphere_map_5.png" );
	  lightProbe[6] = THREE.ImageUtils.loadTexture( "images/sphere_map_6.png" );
	  lightProbe[7] = THREE.ImageUtils.loadTexture( "images/sphere_map_7.png" );
	  lightProbe[8] = THREE.ImageUtils.loadTexture( "images/sphere_map_8.png" );
	  lightProbe[9] = THREE.ImageUtils.loadTexture( "images/sphere_map_9.png" );
	  lightProbe[10] = THREE.ImageUtils.loadTexture( "images/sphere_map_10.png" );
	  lightProbe[11] = THREE.ImageUtils.loadTexture( "images/sphere_map_11.png" );
	  lightProbe[12] = THREE.ImageUtils.loadTexture( "images/sphere_map_12.png" );
	  
	  // Shader
	  for(var i = 1; i <= 12; i++) {
	    material[i] = new THREE.ShaderMaterial({
	      vertexShader: document.getElementById("vertexShader").textContent,
	      fragmentShader: document.getElementById("fragmentShader").textContent,
	      uniforms: {
		 "INPUTIMAGE": { type: "t", value: lightProbe[i] },
		 "VIEWMATRIX": { type: "m4", value: new THREE.Matrix4()},
		 "VIEWMATRIXINVERSE": { type: "m4", value: new THREE.Matrix4()}
	       }
	    });
	  }
	  
	  loadModel("webgl_models/MedFreq_MedAmp.obj");
	  
	  stats = new Stats();
	  stats.domElement.style.position = "absolute";
	  stats.domElement.style.top = "0px";
	  stats.domElement.style.zIndex = 100;
	  container.appendChild( stats.domElement );
	  
	  renderer = new THREE.WebGLRenderer({'antialias':true});
	  renderer.setSize( window.innerWidth, window.innerHeight );
	  container.appendChild( renderer.domElement );
	  
	  window.addEventListener( "resize", onWindowResize, false );
	  
	  effectController = {
	    shapeRotSpeed: 1,
	    envRotSpeed: 0,
	    ModelFreq: 'Med',
	    ModelAmp: 'Med',
	    HighRes: false
	  }
	  
	  effectControllerPresets = {
	    "preset": "Default",
	    "remembered": {
	      "Default": {
		"0": {
		  "shapeRotSpeed": 1,
		  "envRotSpeed": 0,
		}
	      }
	    }
	  };
	  
	  var gui = new dat.GUI({load: effectControllerPresets});
          gui.close();
	  gui.remember(effectController);
	  gui.add(effectController, 'shapeRotSpeed', -5, 5 ).step(1);
	  gui.add(effectController, 'envRotSpeed', -10, 10 ).step(1);
	  
	  var f2 = gui.addFolder('Shape')
	  var controllerModelFreq = f2.add(effectController, 'ModelFreq', ['Low', 'Med', 'High'] );
	  var controllerModelAmp = f2.add(effectController, 'ModelAmp', ['Low', 'Med', 'High'] );
	  var controllerHighRes = f2.add(effectController, 'HighRes' );
          
	  controllerModelFreq.onChange(function(value) {
	    deleteOBJs();
	    if (effectController.HighRes == true) {
	      loadModel('webgl_models/'+value+'Freq_'+effectController.ModelAmp+'AmpHR.obj')
	    } else {
	      loadModel('webgl_models/'+value+'Freq_'+effectController.ModelAmp+'Amp.obj');
	    }
	  });
	  controllerModelAmp.onChange(function(value) {
	    deleteOBJs();
	    if (effectController.HighRes == true) {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+value+'AmpHR.obj');
	    } else {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+value+'Amp.obj');
	    }
	  });
	  controllerHighRes.onChange(function(value) {
	    deleteOBJs();
	    if (value == true) {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+effectController.ModelAmp+'AmpHR.obj');
	    } else {
	      loadModel('webgl_models/'+effectController.ModelFreq+'Freq_'+effectController.ModelAmp+'Amp.obj');
	    }
	  });
	}
	
	function deleteOBJs() {
	  var object;
	  for(var i = 1; i <= 12; i++) {
	      objectNormals = scene.getObjectByName( "blob"+i.toString(),true )
	      scene.remove(objectNormals);
	  }
	}
        
	function loadModel(filename) {
	  var loader = new THREE.OBJLoader( manager );
	  loader.load( filename, function ( object ) {
	    object.children[0].geometry.applyMatrix(new THREE.Matrix4().makeScale( 0.55, 0.55, 0.55 ) );
	    object.children[0].geometry.computeVertexNormals();
	    object.children[0].geometry.computeFaceNormals();
            
            for(var i = 1; i <= 12; i++) {
                var new_obj = object.clone();
		new_obj.children[0].material = material[i];
		if (i==1) {
		  new_obj.translateX( -1.875 );
		  new_obj.translateY( 1.25 );
		} else if (i==2) {
		  new_obj.translateX( -0.625 );
		  new_obj.translateY( 1.25 );
		} else if (i==3) {
		  new_obj.translateX( 0.625 );
		  new_obj.translateY( 1.25 );
		} else if (i==4) {
		  new_obj.translateX( 1.875 );
		  new_obj.translateY( 1.25 );
		} else if (i==5) {
		  new_obj.translateX( -1.875 );
		  new_obj.translateY( 0 );
		} else if (i==6) {
		  new_obj.translateX( -0.625 );
		  new_obj.translateY( 0 );
		} else if (i==7) {
		  new_obj.translateX( 0.625 );
		  new_obj.translateY( 0 );
		} else if (i==8) {
		  new_obj.translateX( 1.875 );
		  new_obj.translateY( 0 );
		} else if (i==9) {
		  new_obj.translateX( -1.875 );
		  new_obj.translateY( -1.25 );
		} else if (i==10) {
		  new_obj.translateX( -0.625 );
		  new_obj.translateY( -1.25 );
		} else if (i==11) {
		  new_obj.translateX( 0.625 );
		  new_obj.translateY( -1.25 );
		} else if (i==12) {
		  new_obj.translateX( 1.875 );
		  new_obj.translateY( -1.25 );
		}
		
                new_obj.name = "blob"+i.toString();
                scene.add( new_obj );
            }
	  } );
	};
        
	function onWindowResize() {
	  aspectRatio = window.innerWidth / window.innerHeight;
	  camera.left = -aspectRatio*2;
	  camera.right = aspectRatio*2;
	  camera.updateProjectionMatrix();
	  
	  renderer.setSize( window.innerWidth, window.innerHeight );
	}
	
	function animate() {
	  requestAnimationFrame( animate );
	  render();
	  stats.update();
	}
	
	function rotateViewMatrix(object,theta) {
	  var VIEWMATRIX = new THREE.Matrix4();
	  var VIEWMATRIXINVERSE = new THREE.Matrix4();
	  var cameraCopy = camera.clone();
	  
	  cameraCopy.position.x = 5 * Math.sin(theta);
	  cameraCopy.position.z = 5 * Math.cos(theta);
	  cameraCopy.lookAt( scene.position );
	  cameraCopy.updateMatrixWorld( true );
	  VIEWMATRIX = cameraCopy.matrixWorld;
	  VIEWMATRIXINVERSE.getInverse(VIEWMATRIX);
	  
	  object.traverse( function ( child ) {
	    if ( child instanceof THREE.Mesh ) {
	      child.material.uniforms.VIEWMATRIX.value = VIEWMATRIX;
	      child.material.uniforms.VIEWMATRIXINVERSE.value = VIEWMATRIXINVERSE;
	    }
	  } );
	}
	
	function render() {
	  var rotationIncrement = 0.00314159;
	  var yAxis = new THREE.Vector3(0,1,0);
	  
	  //var relativeSpeed = 0;
	  
	  environmentRotation = environmentRotation + effectController.envRotSpeed * rotationIncrement;
	  
	  for(var i = 1; i <= 12; i++) {
	      var object = scene.getObjectByName( "blob"+i.toString(), true );
	      if (typeof object != "undefined") {
		object.rotateOnAxis(yAxis,(effectController.shapeRotSpeed * rotationIncrement));
		rotateViewMatrix(object,environmentRotation)
	      }
	  }
	  
	  
	  camera.lookAt( scene.position );
	  camera.updateMatrixWorld( true );
	  renderer.render( scene, camera );
	}
      </script>
    </body>
</html>